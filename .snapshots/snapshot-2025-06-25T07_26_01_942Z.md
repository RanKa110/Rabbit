

# Project Files

- c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\05. Tables\Scripts\EnemySO.cs
- c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\05. Tables\Tables\Enemy\EnemyTable.cs
- c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\02. Scripts\State\Enemy\EnemyState.cs
- c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\02. Scripts\State\Enemy\EnemyStates.cs
- c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\02. Scripts\Enemy\AutoDestroy.cs
- c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\02. Scripts\Enemy\HomingMonster.cs
- c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\02. Scripts\Enemy\HomingProjectile.cs
- c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\02. Scripts\Enemy\MeleeMonster.cs
- c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\02. Scripts\Enemy\MonsterBase.cs
- c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\02. Scripts\Enemy\Projectile.cs
- c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\02. Scripts\Enemy\RangedMonster.cs
- c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\02. Scripts\Enemy\TempAttacker.cs
- c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\02. Scripts\Controller\EnemyController.cs
- c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\02. Scripts\Enemy\EnemyHealthBar.cs

## c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\05. Tables\Scripts\EnemySO.cs
```
using UnityEngine;
using System.Collections.Generic;

public enum EnemyType
{
    Melee,
    Ranged,
    Homing,
    Boss
}

[CreateAssetMenu(fileName = "EnemySO", menuName = "Scriptable Objects/EnemySO")]
public class EnemySO : ScriptableObject, IStatProvider
{
    public EnemyType Type;

    [Tooltip("Detection range for transitioning from Idle to Chasing")]
    public float DetectionRange = 10f;

    [Header("Attack Prefabs")]
    [Tooltip("Projectile prefab for ranged attacks")]
    public GameObject RangedProjectilePrefab;
    
    [Tooltip("Projectile prefab for homing attacks")]
    public GameObject HomingProjectilePrefab;

    // 기존 필드는 호환성을 위해 유지 (deprecated)
    [HideInInspector]
    public GameObject ProjectilePrefab;

    [Header("Base Stats and Modifiers")]
    public List<StatData> EnemyStats;
    public List<StatData> Stats => EnemyStats;
    
    // 타입에 따른 프리팹 반환 메서드
    public GameObject GetProjectilePrefab()
    {
        switch (Type)
        {
            case EnemyType.Ranged:
                return RangedProjectilePrefab != null ? RangedProjectilePrefab : ProjectilePrefab;
            case EnemyType.Homing:
                return HomingProjectilePrefab != null ? HomingProjectilePrefab : ProjectilePrefab;
            default:
                return null;
        }
    }
}
```

## c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\05. Tables\Tables\Enemy\EnemyTable.cs
```
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(fileName = "EnemyTable", menuName = "Tables/EnemyTable", order = 0)]
public class EnemyTable : BaseTable<int, EnemySO>
{
    protected override string[] DataPath => new[] { "Assets/05. Tables/Datas/Enemy" };

    public override void CreateTable()
    {
        Type = GetType();
        DataDic.Clear();
        //foreach (EnemySO item in dataList)
        //{
        //    DataDic[item.ID] = item;
        //}
    }
}
```

## c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\02. Scripts\State\Enemy\EnemyState.cs
```
using UnityEngine;

public enum EnemyState
{
   Idle,     // 대기 상태
   Chasing,  // 추격 상태
   Attack,   // 공격 상태 (근거리/원거리/유도 공격)
   Die       // 사망 상태
}
```

## c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\02. Scripts\State\Enemy\EnemyStates.cs
```
using UnityEngine;
using System.Collections;

namespace EnemyStates
{
    public class IdleState : IState<EnemyController, EnemyState>
    {
        public void OnEnter(EnemyController owner)
        {
            // 이동 정지 - X축 속도를 0으로
            var rb = owner.GetComponent<Rigidbody2D>();
            if (rb != null)
            {
                rb.linearVelocity = new Vector2(0, rb.linearVelocity.y);
            }
            
            // 애니메이션
            var animator = owner.GetComponent<Animator>();
            if (animator != null)
            {
                animator.SetBool("isMoving", false);
            }
        }

        public void OnUpdate(EnemyController owner)
        {
        }

        public void OnExit(EnemyController owner)
        {
        }

        public EnemyState CheckTransition(EnemyController owner)
        {
            if (owner.Target != null && Vector3.Distance(owner.transform.position, owner.Target.Collider.transform.position) <= owner.Data.DetectionRange)
            {
                return EnemyState.Chasing;
            }

            return EnemyState.Idle;
        }
    }

    public class ChasingState : IState<EnemyController, EnemyState>
    {
        public void OnEnter(EnemyController owner)
        {
            // 애니메이션
            var animator = owner.GetComponent<Animator>();
            if (animator != null)
            {
                animator.SetBool("isMoving", true);
            }
        }

        public void OnUpdate(EnemyController owner)
        {
            // 몬스터 컴포넌트에 따른 이동
            var rangedMonster = owner.GetComponent<RangedMonster>();
            var homingMonster = owner.GetComponent<HomingMonster>();
            
            if (rangedMonster != null || homingMonster != null)
            {
                owner.MovementWithDistance(owner.minAttackDistance);
            }
            else
            {
                owner.Movement();
            }
        }

        public void OnExit(EnemyController entity)
        {
        }

        public EnemyState CheckTransition(EnemyController owner)
        {
            if (owner.IsDead)
            {
                return EnemyState.Die;
            }

            if (owner.Target == null)
            {
                return EnemyState.Idle;
            }

            float distance = Vector3.Distance(owner.transform.position, owner.Target.Collider.transform.position);

            if (distance <= owner.StatManager.GetValueSafe(StatType.AttackRange, 3.0f))
            {
                return EnemyState.Attack;
            }

            return EnemyState.Chasing;
        }
    }

    // 통합 공격 상태 (각 몬스터 컴포넌트로 위임)
    public class AttackState : IState<EnemyController, EnemyState>
    {
        private readonly float _atkSpd;
        private readonly float _atkRange;
        private bool _attackDone;

        public AttackState(float atkSpd, float atkRange)
        {
            _atkSpd = atkSpd;
            _atkRange = atkRange;
        }

        public void OnEnter(EnemyController owner)
        {
            owner.StartCoroutine(DoAttack(owner));
        }

        private IEnumerator DoAttack(EnemyController owner)
        {
            _attackDone = false;
            owner.IsAttacking = true;
            owner.CanAttack = false;
            owner.LastAttackTime = Time.time;
            
            // 이동 정지 - X축 속도를 0으로
            var rb = owner.GetComponent<Rigidbody2D>();
            if (rb != null)
            {
                rb.linearVelocity = new Vector2(0, rb.linearVelocity.y);
            }
            
            // 공격 애니메이션 트리거
            var animator = owner.GetComponent<Animator>();
            if (animator != null)
            {
                animator.SetTrigger("Attack");
            }
            
            // 애니메이션 대기
            yield return new WaitForSeconds(0.3f);
            
            // 몬스터 타입별 공격 로직을 각 몬스터 스크립트로 위임
            var meleeMonster = owner.GetComponent<MeleeMonster>();
            var rangedMonster = owner.GetComponent<RangedMonster>();
            var homingMonster = owner.GetComponent<HomingMonster>();
            
            if (meleeMonster != null)
            {
                // 근거리 공격: 범위 내 플레이어 탐지 후 Attack 호출
                if (owner.attackPoint != null)
                {
                    Collider2D[] hitPlayers = Physics2D.OverlapCircleAll(owner.attackPoint.position, owner.attackRadius, owner.playerLayer);
                    
                    foreach (Collider2D hit in hitPlayers)
                    {
                        if (hit.CompareTag("Player"))
                        {
                            IDamageable damageable = hit.GetComponent<IDamageable>();
                            if (damageable != null)
                            {
                                // 타겟에 저장하고 Attack 호출
                                owner.SetAttackTarget(damageable);
                                owner.Attack();
                            }
                            
                            // 넉백 효과
                            Vector2 knockbackDir = (hit.transform.position - owner.transform.position).normalized;
                            Rigidbody2D playerRb = hit.GetComponent<Rigidbody2D>();
                            if (playerRb != null)
                            {
                                playerRb.AddForce(knockbackDir * 5f, ForceMode2D.Impulse);
                            }
                        }
                    }
                }
            }
            else if (rangedMonster != null)
            {
                // 원거리 공격: RangedMonster에게 위임 - 직접 공격 메서드 호출
                rangedMonster.PerformRangedAttack();
            }
            else if (homingMonster != null)
            {
                // 유도 공격: HomingMonster에게 위임
                homingMonster.PerformHomingAttack();
            }
            
            // 공격 애니메이션 종료 대기
            yield return new WaitForSeconds(0.2f);
            
            owner.IsAttacking = false;
            
            // 공격 속도에 따른 대기
            float cooldown = 1f / _atkSpd;
            if (homingMonster != null)
            {
                cooldown *= 1.5f; // 유도 미사일은 더 긴 쿨다운
            }
            
            yield return new WaitForSeconds(cooldown);
            
            owner.CanAttack = true;
            _attackDone = true;
        }

        public void OnUpdate(EnemyController owner)
        {
        }

        public void OnExit(EnemyController owner)
        {
        }

        public EnemyState CheckTransition(EnemyController owner)
        {
            if (owner.IsDead)
            {
                return EnemyState.Die;
            }

            if (!_attackDone)
            {
                return EnemyState.Attack;
            }

            // 타겟과의 거리 확인
            if (owner.Target != null)
            {
                float distance = Vector3.Distance(owner.transform.position, owner.Target.Collider.transform.position);
                
                // 원거리/유도 몬스터의 경우 최소 거리 체크
                var rangedMonster = owner.GetComponent<RangedMonster>();
                var homingMonster = owner.GetComponent<HomingMonster>();
                
                if ((rangedMonster != null || homingMonster != null) && distance < owner.minAttackDistance)
                {
                    return EnemyState.Chasing;
                }
                
                // 타겟이 범위를 벗어났으면 추격
                if (distance > _atkRange)
                {
                    return EnemyState.Chasing;
                }
                
                // 범위 내에 있으면 다시 공격
                return EnemyState.Attack;
            }

            return EnemyState.Chasing;
        }
    }

    public class DieState : IState<EnemyController, EnemyState>
    {
        public void OnEnter(EnemyController owner)
        {
            owner.GetComponent<Collider2D>().enabled = false;
            
            // CharacterController가 있으면 비활성화
            var characterController = owner.GetComponent<CharacterController>();
            if (characterController != null)
            {
                characterController.enabled = false;
            }
            
            // Rigidbody2D가 있으면 정지
            var rb = owner.GetComponent<Rigidbody2D>();
            if (rb != null)
            {
                rb.linearVelocity = Vector2.zero;
                rb.bodyType = RigidbodyType2D.Static;
            }
            
            Object.Destroy(owner.gameObject, 1f);
        }

        public void OnUpdate(EnemyController owner)
        {
        }

        public void OnExit(EnemyController owner)
        {
        }

        public EnemyState CheckTransition(EnemyController owner)
        {
            return EnemyState.Die;
        }
    }
}
```

## c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\02. Scripts\Enemy\AutoDestroy.cs
```
using UnityEngine;

public class AutoDestroy : MonoBehaviour
{
    [Header("자동 삭제 설정")]
    [SerializeField] private float destroyTime = 1f;
    [SerializeField] private bool useParticleSystemDuration = true;
    
    private ParticleSystem particleSystemComponent;
    
    void Start()
    {
        particleSystemComponent = GetComponent<ParticleSystem>();
        
        // 파티클 시스템이 있고 duration 사용 옵션이 켜져있으면
        if (useParticleSystemDuration && particleSystemComponent != null)
        {
            // 파티클 시스템의 전체 재생 시간을 계산
            float totalDuration = particleSystemComponent.main.duration + particleSystemComponent.main.startLifetime.constantMax;
            Destroy(gameObject, totalDuration);
        }
        else
        {
            // 설정된 시간 후 삭제
            Destroy(gameObject, destroyTime);
        }
    }
}

// 더 고급 버전 (오디오도 고려)
public class AdvancedAutoDestroy : MonoBehaviour
{
    [Header("자동 삭제 설정")]
    [SerializeField] private float destroyTime = 1f;
    [SerializeField] private bool waitForParticles = true;
    [SerializeField] private bool waitForAudio = true;
    
    private ParticleSystem[] particleSystems;
    private AudioSource audioSource;
    
    void Start()
    {
        particleSystems = GetComponentsInChildren<ParticleSystem>();
        audioSource = GetComponent<AudioSource>();
        
        float maxDuration = destroyTime;
        
        // 파티클 시스템 시간 계산
        if (waitForParticles && particleSystems.Length > 0)
        {
            foreach (var ps in particleSystems)
            {
                float psDuration = ps.main.duration + ps.main.startLifetime.constantMax;
                maxDuration = Mathf.Max(maxDuration, psDuration);
            }
        }
        
        // 오디오 시간 계산
        if (waitForAudio && audioSource != null && audioSource.clip != null)
        {
            maxDuration = Mathf.Max(maxDuration, audioSource.clip.length);
        }
        
        Destroy(gameObject, maxDuration);
    }
}
```

## c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\02. Scripts\Enemy\HomingMonster.cs
```
using UnityEngine;
using System.Collections;
using TMPro;

// 유도 몬스터 클래스
public class HomingMonster : MonsterBase
{
    [Header("유도 공격 설정")]
    public GameObject homingProjectilePrefab;
    public Transform firePoint;
    public float minAttackDistance = 5f; // 최소 공격 거리 (원거리보다 더 멈)
    
    // EnemyController 참조
    private EnemyController enemyController;
    
    protected override void Start()
    {
        base.Start();
        attackRange = 10f; // 유도 공격 범위 (더 긴 사거리)
        moveSpeed = 1.2f; // 유도 몬스터는 더 느림
        attackCooldown = 2f; // 더 긴 쿨다운
        
        // EnemyController 참조 가져오기
        enemyController = GetComponent<EnemyController>();
        if (enemyController == null)
        {
            Debug.LogError("HomingMonster: EnemyController component not found!");
        }
        else if (enemyController.Data != null)
        {
            // SO에서 프리팹 가져오기 - 새로운 메서드 사용
            GameObject prefabFromSO = enemyController.Data.GetProjectilePrefab();
            if (prefabFromSO != null)
            {
                homingProjectilePrefab = prefabFromSO;
                Debug.Log($"HomingMonster: Projectile prefab loaded from SO: {homingProjectilePrefab.name}");
            }
            else
            {
                Debug.LogWarning("HomingMonster: No projectile prefab found in EnemySO! Make sure HomingProjectilePrefab is set.");
            }
        }
        
        // firePoint가 없으면 자동으로 찾기
        if (firePoint == null)
        {
            // 먼저 자식에서 FirePoint 찾기
            firePoint = transform.Find("FirePoint");
            
            // 없으면 자동 생성
            if (firePoint == null)
            {
                GameObject firePointObj = new GameObject("FirePoint");
                firePointObj.transform.SetParent(transform);
                firePointObj.transform.localPosition = new Vector3(0.5f, 0, 0); // 캐릭터 앞쪽
                firePoint = firePointObj.transform;
                Debug.LogWarning("HomingMonster: FirePoint was created automatically. Please adjust position in prefab.");
            }
        }
    }
    
    protected override void ChaseBehavior()
    {
        if (player == null) return;
        
        float distanceToPlayer = GetDistanceToPlayer();
        
        // 너무 가까우면 뒤로 이동
        if (distanceToPlayer < minAttackDistance)
        {
            Vector2 direction = (transform.position - player.position).normalized;
            rb.linearVelocity = new Vector2(direction.x * moveSpeed, rb.linearVelocity.y);
        }
        // 적정 거리보다 멀면 접근
        else if (distanceToPlayer > attackRange * 0.8f)
        {
            Vector2 direction = (player.position - transform.position).normalized;
            rb.linearVelocity = new Vector2(direction.x * moveSpeed, rb.linearVelocity.y);
        }
        // 적정 거리면 정지
        else
        {
            rb.linearVelocity = new Vector2(0, rb.linearVelocity.y);
        }
        
        // 애니메이션
        if (animator != null)
        {
            animator.SetBool("isMoving", Mathf.Abs(rb.linearVelocity.x) > 0.1f);
        }
    }
    
    protected override void AttackBehavior()
    {
        // 이동 멈춤 - X축 속도를 0으로
        rb.linearVelocity = new Vector2(0, rb.linearVelocity.y);
        
        // 공격 쿨다운 체크
        if (Time.time - lastAttackTime < attackCooldown) return;
        
        if (canAttack && !isAttacking)
        {
            StartCoroutine(HomingAttack());
        }
    }
    
    // 공용 메서드로 변경하여 EnemyController에서 호출 가능하도록 함
    public void PerformHomingAttack()
    {
        // 조건 체크 없이 바로 공격 실행
        FireHomingProjectile();
    }
    
    private void FireHomingProjectile()
    {
        // 디버그 로그
        Debug.Log($"FireHomingProjectile called. Prefab: {homingProjectilePrefab}, FirePoint: {firePoint}");
        
        // 유도 투사체 발사
        if (homingProjectilePrefab != null && firePoint != null)
        {
            Transform targetTransform = null;
            
            // EnemyController에서 타겟 가져오기
            if (enemyController != null && enemyController.Target != null)
            {
                targetTransform = enemyController.Target.Collider.transform;
            }
            // 폴백: player 직접 사용
            else if (player != null)
            {
                targetTransform = player;
            }
            
            if (targetTransform != null)
            {
                GameObject projectile = Instantiate(homingProjectilePrefab, firePoint.position, Quaternion.identity);
                Debug.Log($"Homing projectile instantiated: {projectile.name}");
                
                // 유도 투사체가 알아서 타겟을 추적하도록 함
                HomingProjectile homing = projectile.GetComponent<HomingProjectile>();
                if (homing != null)
                {
                    homing.SetTarget(targetTransform);
                    
                    // EnemyController의 스탯을 사용하거나 자체 스탯 사용
                    homing.damage = enemyController != null ? 
                        enemyController.StatManager.GetValue(StatType.AttackPow) : 
                        attackDamage;
                }
                else
                {
                    Debug.LogWarning("HomingMonster: HomingProjectile component not found on projectile!");
                }
            }
            else
            {
                Debug.LogWarning("HomingMonster: No target found for projectile!");
            }
        }
        else
        {
            Debug.LogWarning($"HomingMonster: Cannot fire projectile! Prefab: {homingProjectilePrefab}, FirePoint: {firePoint}");
        }
    }
    
    private IEnumerator HomingAttack()
    {
        isAttacking = true;
        canAttack = false;
        lastAttackTime = Time.time;
        
        // 공격 애니메이션 트리거
        if (animator != null)
        {
            animator.SetTrigger("Attack");
        }
        
        // 애니메이션 대기
        yield return new WaitForSeconds(0.3f);
        
        // 유도 투사체 발사
        FireHomingProjectile();
        
        // 공격 애니메이션 종료 대기
        yield return new WaitForSeconds(0.2f);
        
        isAttacking = false;
        
        // 쿨다운 대기 (유도 미사일은 좀 더 긴 쿨다운)
        yield return new WaitForSeconds(attackCooldown);
        canAttack = true;
    }
}
```

## c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\02. Scripts\Enemy\HomingProjectile.cs
```
using UnityEngine;

// 유도 투사체 클래스
public class HomingProjectile : MonoBehaviour
{
    [Header("투사체 설정")]
    public float speed = 5f;
    public float damage = 20f;
    public float rotationSpeed = 200f;
    public float lifeTime = 5f;
    
    private Transform target;
    private Rigidbody2D rb;
    
    void Start()
    {
        rb = GetComponent<Rigidbody2D>();
        
        // 생명 시간 후 자동 파괴
        Destroy(gameObject, lifeTime);
    }
    
    void FixedUpdate()
    {
        if (target == null)
        {
            // 타겟이 없으면 직진
            rb.linearVelocity = transform.right * speed;
            return;
        }
        
        // 타겟을 향한 방향 계산
        Vector2 direction = (target.position - transform.position).normalized;
        
        // 현재 방향에서 타겟 방향으로 회전
        float rotateAmount = Vector3.Cross(direction, transform.right).z;
        rb.angularVelocity = -rotateAmount * rotationSpeed;
        
        // 앞으로 이동
        rb.linearVelocity = transform.right * speed;
    }
    
    public void SetTarget(Transform newTarget)
    {
        target = newTarget;
    }
    
    private void OnTriggerEnter2D(Collider2D collision)
    {
        if (collision.CompareTag("Player"))
        {
            // 플레이어에게 데미지
            IDamageable damageable = collision.GetComponent<IDamageable>();
            if (damageable != null)
            {
                // 임시 공격자 객체 생성 (데미지만 전달)
                var tempAttacker = new TempAttacker(damage);
                damageable.TakeDamage(tempAttacker);
            }
            
            // 투사체 파괴
            Destroy(gameObject);
        }
        else if (collision.CompareTag("Ground") || collision.CompareTag("Wall"))
        {
            // 벽이나 땅에 충돌시 파괴
            Destroy(gameObject);
        }
    }
} 
```

## c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\02. Scripts\Enemy\MeleeMonster.cs
```
using UnityEngine;
using System.Collections;
using TMPro;

// 근거리 몬스터 클래스
public class MeleeMonster : MonsterBase
{
    [Header("근거리 공격 설정")]
    public Transform attackPoint;
    public float attackRadius = 1.5f;
    public LayerMask playerLayer;
    
    // EnemyController 참조
    private EnemyController enemyController;
    
    protected override void Start()
    {
        base.Start();
        attackRange = 1.5f; // 근거리 공격 범위
        
        // EnemyController 참조 가져오기
        enemyController = GetComponent<EnemyController>();
        if (enemyController == null)
        {
            Debug.LogError("EnemyController component not found on MeleeMonster!");
        }
    }
    
    protected override void AttackBehavior()
    {
        // 이동 멈춤 - X축 속도를 0으로
        rb.linearVelocity = new Vector2(0, rb.linearVelocity.y);
        
        // 공격 쿨다운 체크
        if (Time.time - lastAttackTime < attackCooldown) return;
        
        if (canAttack && !isAttacking)
        {
            StartCoroutine(MeleeAttack());
        }
    }
    
    private IEnumerator MeleeAttack()
    {
        isAttacking = true;
        canAttack = false;
        lastAttackTime = Time.time;
        
        // 공격 애니메이션 트리거
        if (animator != null)
        {
            animator.SetTrigger("Attack");
        }
        
        // 공격 애니메이션 대기
        yield return new WaitForSeconds(0.3f);
        
        // 공격 범위 내의 플레이어 탐지
        if (attackPoint != null)
        {
            Collider2D[] hitPlayers = Physics2D.OverlapCircleAll(attackPoint.position, attackRadius, playerLayer);
            
            foreach (Collider2D hit in hitPlayers)
            {
                if (hit.CompareTag("Player"))
                {
                    IDamageable damageable = hit.GetComponent<IDamageable>();
                    if (damageable != null && enemyController != null)
                    {
                        // EnemyController의 SetAttackTarget과 Attack 사용
                        enemyController.SetAttackTarget(damageable);
                        enemyController.Attack();
                    }
                    else if (damageable == null)
                    {
                        // 안전한 데미지 처리 (호환성 유지)
                        DealDamageToPlayer(hit.gameObject, attackDamage);
                    }
                    
                    // 넉백 효과
                    Vector2 knockbackDir = (hit.transform.position - transform.position).normalized;
                    Rigidbody2D playerRb = hit.GetComponent<Rigidbody2D>();
                    if (playerRb != null)
                    {
                        playerRb.AddForce(knockbackDir * 5f, ForceMode2D.Impulse);
                    }
                }
            }
        }
        
        // 공격 애니메이션 종료 대기
        yield return new WaitForSeconds(0.2f);
        
        isAttacking = false;
        
        // 쿨다운 대기
        yield return new WaitForSeconds(attackCooldown);
        canAttack = true;
    }
    
    // 공격 범위 시각화 (에디터용)
    private void OnDrawGizmosSelected()
    {
        if (attackPoint == null) return;
        
        Gizmos.color = Color.red;
        Gizmos.DrawWireSphere(attackPoint.position, attackRadius);
    }
}
```

## c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\02. Scripts\Enemy\MonsterBase.cs
```
using UnityEngine;
using System.Collections;
using TMPro;

// 몬스터 기본 클래스
public abstract class MonsterBase : MonoBehaviour, IAttackable
{
    [Header("기본 스탯")]
    public float maxHealth = 100f;
    public float currentHealth;
    public float moveSpeed = 2f;
    public float attackDamage = 10f;
    public float attackCooldown = 1f;
    public float detectionRange = 10f;
    public float attackRange = 2f;
    
    [Header("컴포넌트")]
    protected Rigidbody2D rb;
    protected Animator animator;
    protected SpriteRenderer spriteRenderer;
    protected Transform player;
    protected EnemyHealthBar healthBar; // HP바 컴포넌트 추가
    
    [Header("상태")]
    protected bool isAttacking = false;
    protected bool isDead = false;
    protected bool canAttack = true;
    protected float lastAttackTime;
    
    // IAttackable 구현
    public StatBase AttackStat { get; protected set; }
    public IDamageable Target { get; protected set; }
    
    // 몬스터 상태 enum
    public enum MonsterState
    {
        Idle,
        Patrol,
        Chase,
        Attack,
        Dead
    }
    
    public MonsterState currentState = MonsterState.Idle;
    
    protected virtual void Start()
    {
        rb = GetComponent<Rigidbody2D>();
        animator = GetComponent<Animator>();
        spriteRenderer = GetComponent<SpriteRenderer>();
        
        // HP바 컴포넌트 가져오기 또는 추가
        healthBar = GetComponent<EnemyHealthBar>();
        if (healthBar == null)
        {
            healthBar = gameObject.AddComponent<EnemyHealthBar>();
            Debug.Log($"{gameObject.name}: EnemyHealthBar component added automatically");
        }
        
        currentHealth = maxHealth;
        
        // 플레이어 찾기
        GameObject playerObj = GameObject.FindGameObjectWithTag("Player");
        if (playerObj != null)
        {
            player = playerObj.transform;
        }
        
        // AttackStat 초기화
        AttackStat = new CalculatedStat(StatType.AttackPow, attackDamage);
    }
    
    protected virtual void Update()
    {
        if (isDead) return;
        
        // 플레이어와의 거리 체크
        float distanceToPlayer = GetDistanceToPlayer();
        
        // 상태 머신
        switch (currentState)
        {
            case MonsterState.Idle:
                IdleBehavior();
                if (distanceToPlayer <= detectionRange)
                {
                    currentState = MonsterState.Chase;
                }
                break;
                
            case MonsterState.Chase:
                ChaseBehavior();
                if (distanceToPlayer > detectionRange)
                {
                    currentState = MonsterState.Idle;
                }
                else if (distanceToPlayer <= attackRange)
                {
                    currentState = MonsterState.Attack;
                }
                break;
                
            case MonsterState.Attack:
                AttackBehavior();
                if (distanceToPlayer > attackRange)
                {
                    currentState = MonsterState.Chase;
                }
                break;
        }
        
        // 스프라이트 방향 전환
        UpdateSpriteDirection();
    }
    
    protected virtual void IdleBehavior()
    {
        // 기본 대기 동작 - X축 속도를 0으로 설정
        rb.linearVelocity = new Vector2(0, rb.linearVelocity.y);
    }
    
    protected virtual void ChaseBehavior()
    {
        if (player == null) return;
        
        // 플레이어 방향으로 이동
        Vector2 direction = (player.position - transform.position).normalized;
        rb.linearVelocity = new Vector2(direction.x * moveSpeed, rb.linearVelocity.y);
        
        // 애니메이션
        if (animator != null)
        {
            animator.SetBool("isMoving", true);
        }
    }
    
    protected abstract void AttackBehavior();
    
    protected virtual void UpdateSpriteDirection()
    {
        if (player == null) return;
        
        // 플레이어가 왼쪽에 있으면 왼쪽을 봄
        if (player.position.x < transform.position.x)
        {
            spriteRenderer.flipX = true;
        }
        else
        {
            spriteRenderer.flipX = false;
        }
    }
    
    protected float GetDistanceToPlayer()
    {
        if (player == null) return float.MaxValue;
        return Vector2.Distance(transform.position, player.position);
    }
    
    public virtual void TakeDamage(float damage)
    {
        if (isDead) return;
        
        currentHealth -= damage;
        
        // HP바 업데이트
        if (healthBar != null)
        {
            healthBar.SetHealth(currentHealth, maxHealth);
            healthBar.ShowHealthBar(); // 데미지를 받으면 HP바 표시
        }
        
        // 피격 효과
        StartCoroutine(HitEffect());
        
        if (currentHealth <= 0)
        {
            Die();
        }
    }
    
    protected virtual IEnumerator HitEffect()
    {
        spriteRenderer.color = Color.red;
        yield return new WaitForSeconds(0.1f);
        spriteRenderer.color = Color.white;
    }
    
    protected virtual void Die()
    {
        isDead = true;
        currentState = MonsterState.Dead;
        
        // HP바 숨기기
        if (healthBar != null)
        {
            healthBar.HideHealthBar();
        }
        
        // 충돌체 비활성화
        GetComponent<Collider2D>().enabled = false;
        
        // 사망 애니메이션
        if (animator != null)
        {
            animator.SetTrigger("Death");
        }
        
        // 일정 시간 후 제거
        Destroy(gameObject, 2f);
    }
    
    // IAttackable 구현
    public virtual void Attack()
    {
        if (Target != null)
        {
            Target.TakeDamage(this);
        }
    }
    
    // 안전한 플레이어 데미지 처리 메서드
    protected virtual void DealDamageToPlayer(GameObject playerObject, float damage)
    {
        if (playerObject == null) return;
        
        // IDamageable 인터페이스 확인
        IDamageable damageable = playerObject.GetComponent<IDamageable>();
        if (damageable != null)
        {
            damageable.TakeDamage(this);
            return;
        }
        
        // PlayerController 직접 접근 (임시 호환성)
        PlayerController playerController = playerObject.GetComponent<PlayerController>();
        if (playerController != null)
        {
            // PlayerController에 TakeDamage가 없으므로 로그만 출력
            Debug.Log($"Monster dealt {damage} damage to player (PlayerController doesn't implement TakeDamage yet)");
            // 나중에 팀원이 PlayerController에 IDamageable을 구현하면 위의 IDamageable 체크가 작동할 것입니다.
        }
    }
    
    // 플레이어와 충돌 시
    protected virtual void OnCollisionEnter2D(Collision2D collision)
    {
        if (collision.gameObject.CompareTag("Player") && !isDead)
        {
            // 안전한 데미지 처리
            DealDamageToPlayer(collision.gameObject, attackDamage);
        }
    }
    
    // ===== Animation Event 함수들 =====
    // 애니메이션에서 호출될 수 있는 기본 함수들
    
    // Idle 애니메이션 이벤트 - 가장 중요! 이 함수가 없어서 에러가 발생합니다
    public void Idle()
    {
        // Idle 애니메이션에서 호출되는 함수
        // virtual이 아닌 일반 public 함수로 선언
        // 필요한 경우 여기에 로직 추가 가능
    }
    
    // 공격 애니메이션에서 호출
    public virtual void OnAttackHit()
    {
        Debug.Log($"{gameObject.name}: OnAttackHit called from animation");
    }
    
    // 공격 시작 시 호출
    public virtual void OnAttackStart()
    {
        Debug.Log($"{gameObject.name}: OnAttackStart called from animation");
    }
    
    // 공격 종료 시 호출
    public virtual void OnAttackEnd()
    {
        Debug.Log($"{gameObject.name}: OnAttackEnd called from animation");
    }
    
    // 발걸음 소리 등
    public virtual void OnFootstep()
    {
        Debug.Log($"{gameObject.name}: OnFootstep called from animation");
    }
    
    // 사망 애니메이션 종료
    public virtual void OnDeathAnimationEnd()
    {
        Debug.Log($"{gameObject.name}: OnDeathAnimationEnd called from animation");
        Destroy(gameObject);
    }
    
    // Move/Walk 애니메이션 이벤트
    public void Move()
    {
        // Move 애니메이션에서 호출되는 함수
    }
    
    // Run 애니메이션 이벤트
    public void Run()
    {
        // Run 애니메이션에서 호출되는 함수
    }
    
    // Attack 애니메이션 이벤트
    public void OnAttackAnimation()
    {
        // Attack 애니메이션에서 호출되는 함수
        // IAttackable의 Attack()과 구별하기 위해 이름 변경
    }
    
    // 일반적인 애니메이션 이벤트
    public void AnimationEvent()
    {
        // 범용 애니메이션 이벤트 함수
    }
    
    public void AnimationEvent(string parameter)
    {
        // 파라미터를 받는 범용 애니메이션 이벤트
        Debug.Log($"{gameObject.name}: AnimationEvent called with parameter: {parameter}");
    }
    
    // 추가 애니메이션 이벤트들 (필요시 사용)
    public void Step() { }  // 발걸음
    public void Land() { }  // 착지
    public void Jump() { }  // 점프
    public void Hit() { }   // 피격
    public void Death() { } // 사망
}
```

## c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\02. Scripts\Enemy\Projectile.cs
```
using UnityEngine;
using TMPro;

// 투사체 클래스
public class Projectile : MonoBehaviour
{
    private float damage;
    private float speed;
    private Vector2 direction;
    private Rigidbody2D rb;
    
    [Header("투사체 설정")]
    public float lifeTime = 5f;
    public bool destroyOnHit = true;
    public GameObject hitEffectPrefab;
    
    private bool isInitialized = false;
    private GameObject owner; // 발사한 몬스터 참조
    
    private void Awake()
    {
        rb = GetComponent<Rigidbody2D>();
    }
    
    private void Start()
    {
        // Initialize가 호출되지 않았다면 경고
        if (!isInitialized)
        {
            Debug.LogWarning("Projectile started without initialization!");
        }
        
        Destroy(gameObject, lifeTime);
    }
    
    public void Initialize(Vector2 dir, float spd, float dmg)
    {
        direction = dir;
        speed = spd;
        damage = dmg;
        isInitialized = true;
        
        // Awake에서 rb를 가져왔으므로 바로 사용 가능
        if (rb == null)
        {
            rb = GetComponent<Rigidbody2D>();
        }
        
        if (rb != null)
        {
            rb.linearVelocity = direction * speed;
            Debug.Log($"Projectile velocity set to: {rb.linearVelocity}");
        }
        else
        {
            Debug.LogError("Projectile: Rigidbody2D not found!");
        }
    }
    
    // 발사한 몬스터 설정
    public void SetOwner(GameObject ownerObject)
    {
        owner = ownerObject;
        
        // 발사한 몬스터와의 충돌 무시
        if (owner != null)
        {
            Collider2D ownerCollider = owner.GetComponent<Collider2D>();
            Collider2D projectileCollider = GetComponent<Collider2D>();
            
            if (ownerCollider != null && projectileCollider != null)
            {
                Physics2D.IgnoreCollision(ownerCollider, projectileCollider);
                Debug.Log($"Ignoring collision between projectile and owner: {owner.name}");
            }
        }
    }
    
    private void FixedUpdate()
    {
        // 만약 velocity가 0이면 다시 설정
        if (isInitialized && rb != null && rb.linearVelocity.magnitude < 0.1f)
        {
            rb.linearVelocity = direction * speed;
        }
    }
    
    private void OnTriggerEnter2D(Collider2D collision)
    {
        // 자기 자신을 발사한 몬스터와의 충돌은 무시
        if (owner != null && collision.gameObject == owner)
        {
            Debug.Log("Projectile ignoring collision with owner");
            return;
        }
        
        // Enemy 태그와의 충돌도 무시 (같은 팀)
        if (collision.CompareTag("Enemy"))
        {
            Debug.Log("Projectile ignoring collision with other enemy");
            return;
        }
        
        // 플레이어에게 맞았을 때
        if (collision.CompareTag("Player"))
        {
            Debug.Log($"Projectile hit player! Damage: {damage}");
            
            // 안전한 데미지 처리
            IDamageable damageable = collision.GetComponent<IDamageable>();
            if (damageable != null)
            {
                // IAttackable이 필요하므로 임시 구현체 생성
                var tempAttacker = new TempAttacker(damage);
                damageable.TakeDamage(tempAttacker);
            }
            else
            {
                // PlayerController에 TakeDamage가 없으므로 로그만 출력
                Debug.Log($"Projectile hit player for {damage} damage (PlayerController doesn't implement IDamageable yet)");
            }
            
            // 히트 이펙트
            if (hitEffectPrefab != null)
            {
                Instantiate(hitEffectPrefab, transform.position, Quaternion.identity);
            }
            
            if (destroyOnHit)
            {
                Destroy(gameObject);
            }
        }
        // 벽이나 지형에 맞았을 때
        else if (collision.CompareTag("Ground") || collision.CompareTag("Wall"))
        {
            Debug.Log($"Projectile hit {collision.tag}");
            
            if (hitEffectPrefab != null)
            {
                Instantiate(hitEffectPrefab, transform.position, Quaternion.identity);
            }
            
            Destroy(gameObject);
        }
        else
        {
            // 다른 태그와 충돌 시 로그
            Debug.Log($"Projectile hit object with tag: {collision.tag}");
        }
    }
    
    private void OnBecameInvisible()
    {
        // 화면 밖으로 나가면 삭제
        Destroy(gameObject);
    }
    
    // 디버그용
    private void OnDrawGizmos()
    {
        if (Application.isPlaying && isInitialized)
        {
            Gizmos.color = Color.red;
            Gizmos.DrawRay(transform.position, direction * 2f);
        }
    }
}
```

## c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\02. Scripts\Enemy\RangedMonster.cs
```
using UnityEngine;
using System.Collections;
using TMPro;

// 원거리 몬스터 클래스
public class RangedMonster : MonsterBase
{
    [Header("원거리 공격 설정")]
    public GameObject projectilePrefab;
    public Transform firePoint;
    public float projectileSpeed = 10f;
    public float minAttackDistance = 3f; // 최소 공격 거리
    
    // EnemyController 참조
    private EnemyController enemyController;
    
    protected override void Start()
    {
        base.Start();
        attackRange = 8f; // 원거리 공격 범위
        moveSpeed = 1.5f; // 원거리 몬스터는 조금 느림
        
        // EnemyController 참조 가져오기
        enemyController = GetComponent<EnemyController>();
        if (enemyController == null)
        {
            Debug.LogError("RangedMonster: EnemyController component not found!");
        }
        else if (enemyController.Data != null)
        {
            // SO에서 프리팹 가져오기 - 새로운 메서드 사용
            GameObject prefabFromSO = enemyController.Data.GetProjectilePrefab();
            if (prefabFromSO != null)
            {
                projectilePrefab = prefabFromSO;
                Debug.Log($"RangedMonster: Projectile prefab loaded from SO: {projectilePrefab.name}");
            }
            else
            {
                Debug.LogWarning("RangedMonster: No projectile prefab found in EnemySO! Make sure RangedProjectilePrefab is set.");
                
                // 디버그: SO의 값들 확인
                Debug.LogWarning($"RangedProjectilePrefab: {enemyController.Data.RangedProjectilePrefab}");
                Debug.LogWarning($"Legacy ProjectilePrefab: {enemyController.Data.ProjectilePrefab}");
                Debug.LogWarning($"Enemy Type: {enemyController.Data.Type}");
            }
        }
        
        // 현재 projectilePrefab 상태 확인
        Debug.Log($"RangedMonster Start - Final projectilePrefab: {projectilePrefab}");
        
        // firePoint가 없으면 자동으로 찾기
        if (firePoint == null)
        {
            // 먼저 자식에서 FirePoint 찾기
            firePoint = transform.Find("FirePoint");
            
            // 없으면 AttackPoint 찾기
            if (firePoint == null)
            {
                firePoint = transform.Find("AttackPoint");
            }
            
            // 그래도 없으면 자동 생성
            if (firePoint == null)
            {
                GameObject firePointObj = new GameObject("FirePoint");
                firePointObj.transform.SetParent(transform);
                firePointObj.transform.localPosition = new Vector3(0.5f, 0, 0); // 캐릭터 앞쪽
                firePoint = firePointObj.transform;
                Debug.LogWarning("RangedMonster: FirePoint was created automatically. Please adjust position in prefab.");
            }
        }
        
        Debug.Log($"RangedMonster Start - FirePoint: {firePoint}");
    }
    
    protected override void ChaseBehavior()
    {
        if (player == null) return;
        
        float distanceToPlayer = GetDistanceToPlayer();
        
        // 너무 가까우면 뒤로 이동
        if (distanceToPlayer < minAttackDistance)
        {
            Vector2 direction = (transform.position - player.position).normalized;
            rb.linearVelocity = new Vector2(direction.x * moveSpeed, rb.linearVelocity.y);
        }
        // 적정 거리보다 멀면 접근
        else if (distanceToPlayer > attackRange * 0.8f)
        {
            Vector2 direction = (player.position - transform.position).normalized;
            rb.linearVelocity = new Vector2(direction.x * moveSpeed, rb.linearVelocity.y);
        }
        // 적정 거리면 정지
        else
        {
            rb.linearVelocity = new Vector2(0, rb.linearVelocity.y);
        }
        
        // 애니메이션
        if (animator != null)
        {
            animator.SetBool("isMoving", Mathf.Abs(rb.linearVelocity.x) > 0.1f);
        }
    }
    
    protected override void AttackBehavior()
    {
        // 이동 멈춤 - X축 속도를 0으로
        rb.linearVelocity = new Vector2(0, rb.linearVelocity.y);
        
        // 공격 쿨다운 체크
        if (Time.time - lastAttackTime < attackCooldown) return;
        
        if (canAttack && !isAttacking)
        {
            StartCoroutine(RangedAttack());
        }
    }
    
    // 공용 메서드로 변경하여 EnemyController에서 호출 가능하도록 함
    public void PerformRangedAttack()
    {
        // 조건 체크 없이 바로 공격 실행
        FireProjectile();
    }
    
    private void FireProjectile()
    {
        // 디버그 로그
        Debug.Log($"FireProjectile called. Prefab: {projectilePrefab}, FirePoint: {firePoint}");
        
        // null 체크를 더 자세히
        if (projectilePrefab == null)
        {
            Debug.LogError("RangedMonster: projectilePrefab is null!");
            return;
        }
        
        if (firePoint == null)
        {
            Debug.LogError("RangedMonster: firePoint is null!");
            return;
        }
        
        // 투사체 발사
        Transform targetTransform = null;
        
        // EnemyController에서 타겟 가져오기
        if (enemyController != null && enemyController.Target != null)
        {
            targetTransform = enemyController.Target.Collider.transform;
        }
        // 폴백: player 직접 사용
        else if (player != null)
        {
            targetTransform = player;
        }
        
        if (targetTransform == null)
        {
            Debug.LogWarning("RangedMonster: No target found for projectile!");
            return;
        }
        
        // firePoint 위치를 약간 앞으로 조정하여 투사체 생성
        Vector2 direction = (targetTransform.position - firePoint.position).normalized;
        Vector3 spawnPosition = firePoint.position + (Vector3)(direction * 0.5f); // 0.5 유닛 앞에 생성
        
        GameObject projectile = Instantiate(projectilePrefab, spawnPosition, Quaternion.identity);
        Debug.Log($"Projectile instantiated: {projectile.name} at position {spawnPosition}");
        
        // 투사체에 발사한 몬스터 설정
        Projectile proj = projectile.GetComponent<Projectile>();
        if (proj != null)
        {
            // 발사한 몬스터 설정 (충돌 무시를 위해)
            proj.SetOwner(gameObject);
            
            // EnemyController의 스탯을 사용하거나 자체 스탯 사용
            float damage = enemyController != null ? 
                enemyController.StatManager.GetValue(StatType.AttackPow) : 
                attackDamage;
            
            proj.Initialize(direction, projectileSpeed, damage);
            Debug.Log($"Projectile initialized with damage: {damage}, speed: {projectileSpeed}");
        }
        else
        {
            Debug.LogWarning("Projectile component not found, using Rigidbody2D directly");
            // 기본 투사체 움직임
            Rigidbody2D projRb = projectile.GetComponent<Rigidbody2D>();
            if (projRb != null)
            {
                projRb.linearVelocity = direction * projectileSpeed;
            }
            else
            {
                Debug.LogError("No Rigidbody2D found on projectile!");
            }
        }
        
        // 투사체 회전
        float angle = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;
        projectile.transform.rotation = Quaternion.AngleAxis(angle, Vector3.forward);
    }
    
    private IEnumerator RangedAttack()
    {
        isAttacking = true;
        canAttack = false;
        lastAttackTime = Time.time;
        
        // 공격 애니메이션 트리거
        if (animator != null)
        {
            animator.SetTrigger("Attack");
        }
        
        // 애니메이션 대기
        yield return new WaitForSeconds(0.3f);
        
        // 투사체 발사
        FireProjectile();
        
        // 공격 애니메이션 종료 대기
        yield return new WaitForSeconds(0.2f);
        
        isAttacking = false;
        
        // 쿨다운 대기
        yield return new WaitForSeconds(attackCooldown);
        canAttack = true;
    }
}
```

## c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\02. Scripts\Enemy\TempAttacker.cs
```
// 임시 공격자 클래스 (투사체용)
public class TempAttacker : IAttackable
{
    public StatBase AttackStat { get; private set; }
    public IDamageable Target { get; set; }
    
    public TempAttacker(float damage)
    {
        AttackStat = new CalculatedStat(StatType.AttackPow, damage);
    }
    
    public void Attack()
    {
        // 투사체는 직접 공격하지 않음
    }
} 
```

## c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\02. Scripts\Controller\EnemyController.cs
```
using UnityEngine;
using System;

//[RequireComponent(typeof(CharacterController))]
[RequireComponent(typeof(StatManager))]
[RequireComponent(typeof(StatusEffectManager))]

public class EnemyController : BaseController<EnemyController, EnemyState>, IAttackable, IDamageable
{
    private CharacterController _characterController;
    private IDamageable _target;
    private bool _isDead;
    private EnemyHealthBar _healthBar; // HP바 컴포넌트 추가

    public bool IsDead => _isDead;
    public Collider2D Collider { get; private set; }
    public StatBase AttackStat { get; private set; }
    public IDamageable Target => _target;

    [SerializeField] private EnemySO _data;
    public EnemySO Data => _data;

    [Header("공격 설정")]
    public Transform attackPoint;
    public float attackRadius = 1.5f;
    public LayerMask playerLayer;
    public float minAttackDistance = 3f;
    
    [Header("이펙트")]
    public GameObject hitEffectPrefab;
    
    // 컴포넌트
    private Rigidbody2D _rigidbody2D;
    private Animator _animator;
    private SpriteRenderer _spriteRenderer;
    
    // 상태 변수
    public bool IsAttacking { get; set; }
    public bool CanAttack { get; set; } = true;
    public float LastAttackTime { get; set; }

    protected override void Awake()
    {
        base.Awake();

        _characterController = GetComponent<CharacterController>();
        _rigidbody2D = GetComponent<Rigidbody2D>();
        _animator = GetComponent<Animator>();
        _spriteRenderer = GetComponent<SpriteRenderer>();
        Collider = GetComponent<Collider2D>();
        
        // HP바 컴포넌트 가져오기 또는 추가
        _healthBar = GetComponent<EnemyHealthBar>();
        if (_healthBar == null)
        {
            _healthBar = gameObject.AddComponent<EnemyHealthBar>();
            Debug.Log($"{gameObject.name}: EnemyHealthBar component added automatically");
        }
        
        StatManager.Initialize(Data, this);
        AttackStat = StatManager.GetStat<CalculatedStat>(StatType.AttackPow);
    }

    protected override void Start()
    {
        base.Start();
        
        // HP바 초기화
        if (_healthBar != null)
        {
            float maxHp = StatManager.GetValueSafe(StatType.MaxHp, 100f);
            float curHp = StatManager.GetValueSafe(StatType.CurHp, maxHp);
            _healthBar.SetHealth(curHp, maxHp);
        }
    }

    protected override void Update()
    {
        base.Update();

        FindTarget();
        UpdateSpriteDirection();
    }

    protected override IState<EnemyController, EnemyState> GetState(EnemyState state) => state switch
    {
        EnemyState.Idle => new EnemyStates.IdleState(),
        EnemyState.Chasing => new EnemyStates.ChasingState(),
        EnemyState.Attack => new EnemyStates.AttackState(
            StatManager.GetValueSafe(StatType.AttackSpd, 1.0f), // 기본 공격 속도 1.0
            StatManager.GetValueSafe(StatType.AttackRange, 3.0f)), // 기본 공격 범위 3.0
        EnemyState.Die => new EnemyStates.DieState(),
        _ => null
    };

    public override void Movement()
    {
        base.Movement();    

        if (_target == null)
        {
            return;
        }

        float speed = StatManager.GetValueSafe(StatType.MoveSpeed, 5f);
        Vector3 dir = (_target.Collider.transform.position - transform.position).normalized;

        if (_characterController != null && _characterController.enabled)
        {
            _characterController.Move(dir * speed * Time.deltaTime);
        }
        else if (_rigidbody2D != null)
        {
            // X축만 이동, Y축은 중력에 맡김
            _rigidbody2D.linearVelocity = new Vector2(dir.x * speed, _rigidbody2D.linearVelocity.y);
        }
    }

    public void MovementWithDistance(float minDistance)
    {
        if (_target == null) return;

        float speed = StatManager.GetValueSafe(StatType.MoveSpeed, 5f);
        float distanceToTarget = Vector3.Distance(transform.position, _target.Collider.transform.position);
        
        Vector3 dir;
        
        // 너무 가까우면 뒤로 이동
        if (distanceToTarget < minDistance)
        {
            dir = (transform.position - _target.Collider.transform.position).normalized;
        }
        // 적정 거리보다 멀면 접근
        else if (distanceToTarget > StatManager.GetValueSafe(StatType.AttackRange, 3.0f) * 0.8f)
        {
            dir = (_target.Collider.transform.position - transform.position).normalized;
        }
        // 적정 거리면 정지
        else
        {
            if (_rigidbody2D != null)
            {
                // X축만 정지, Y축은 중력에 맡김
                _rigidbody2D.linearVelocity = new Vector2(0, _rigidbody2D.linearVelocity.y);
            }
            return;
        }

        if (_characterController != null && _characterController.enabled)
        {
            _characterController.Move(dir * speed * Time.deltaTime);
        }
        else if (_rigidbody2D != null)
        {
            // X축만 이동, Y축은 중력에 맡김
            _rigidbody2D.linearVelocity = new Vector2(dir.x * speed, _rigidbody2D.linearVelocity.y);
        }
    }

    public void Attack()
    {
        _target?.TakeDamage(this);
    }

    // Melee 공격을 위한 타겟 설정 메서드
    public void SetAttackTarget(IDamageable target)
    {
        _target = target;
    }

    public override void FindTarget()
    {
        if (_target != null && !_target.IsDead)
        {
            return;
        }

        var playerObj = GameObject.FindGameObjectWithTag("Player");

        if (playerObj != null)
        {
            _target = playerObj.GetComponent<IDamageable>();
            if (_target == null)
            {
                // PlayerController가 IDamageable을 구현하지 않은 경우 처리
                Debug.LogWarning("Player doesn't implement IDamageable interface");
            }
        }
    }

    private void UpdateSpriteDirection()
    {
        if (_target == null || _spriteRenderer == null) return;
        
        // 타겟이 왼쪽에 있으면 왼쪽을 봄
        if (_target.Collider.transform.position.x < transform.position.x)
        {
            _spriteRenderer.flipX = true;
        }
        else
        {
            _spriteRenderer.flipX = false;
        }
    }

    public void Dead()
    {
        _isDead = true;
        
        // HP바 숨기기
        if (_healthBar != null)
        {
            _healthBar.HideHealthBar();
        }
        
        // 피격 효과 시작
        StartCoroutine(DeathEffect());
    }

    public void TakeDamage(IAttackable attacker)
    {
        if (_isDead) return;
        
        float damage = attacker.AttackStat?.Value ?? 0;
        
        // HP 감소 (데미지 처리)
        StatManager.Consume(StatType.CurHp, StatModifierType.Base, damage);
        
        // HP바 업데이트
        if (_healthBar != null)
        {
            float maxHp = StatManager.GetValueSafe(StatType.MaxHp, 100f);
            float currentHp = StatManager.GetValueSafe(StatType.CurHp, maxHp);
            _healthBar.SetHealth(currentHp, maxHp);
            _healthBar.ShowHealthBar(); // 데미지를 받으면 HP바 표시
        }
        
        // 피격 효과
        StartCoroutine(HitEffect());
        
        // HP 체크 (StatManager의 Consume에서 자동으로 Dead()가 호출되지만 상태 변경은 여기서)
        float currentHealth = StatManager.GetValueSafe(StatType.CurHp, 0f);
        if (currentHealth <= 0)
        {
            ChangeState(EnemyState.Die);
        }
    }

    private System.Collections.IEnumerator HitEffect()
    {
        if (_spriteRenderer != null)
        {
            _spriteRenderer.color = Color.red;
            yield return new WaitForSeconds(0.1f);
            _spriteRenderer.color = Color.white;
        }
    }
    
    private System.Collections.IEnumerator DeathEffect()
    {
        if (_spriteRenderer != null)
        {
            // 페이드 아웃 효과
            Color originalColor = _spriteRenderer.color;
            float elapsed = 0f;
            float duration = 1f;
            
            while (elapsed < duration)
            {
                elapsed += Time.deltaTime;
                float alpha = Mathf.Lerp(1f, 0f, elapsed / duration);
                _spriteRenderer.color = new Color(originalColor.r, originalColor.g, originalColor.b, alpha);
                yield return null;
            }
            
            // 완전히 투명해지면 오브젝트 비활성화 또는 삭제
            gameObject.SetActive(false);
        }
    }

    // 공격 범위 시각화 (에디터용)
    private void OnDrawGizmosSelected()
    {
        // 근거리 공격 범위 (MeleeMonster가 있을 때만)
        if (GetComponent<MeleeMonster>() != null && attackPoint != null)
        {
            Gizmos.color = Color.red;
            Gizmos.DrawWireSphere(attackPoint.position, attackRadius);
        }
        
        // 감지 범위
        if (Data != null)
        {
            Gizmos.color = Color.yellow;
            Gizmos.DrawWireSphere(transform.position, Data.DetectionRange);
        }
    }
}
```

## c:\Users\super\OneDrive\문서\GitHub\2DAction\Rabbit\Assets\02. Scripts\Enemy\EnemyHealthBar.cs
```
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class EnemyHealthBar : MonoBehaviour
{
    [Header("HP바 설정")]
    [SerializeField] private GameObject healthBarPrefab; // HP바 프리팹
    [SerializeField] private Vector3 worldOffset = new Vector3(0, 1.5f, 0); // 월드 공간 오프셋
    [SerializeField] private Vector2 screenOffset = new Vector2(0, 50f); // 스크린 공간 오프셋 (픽셀)
    [SerializeField] private bool hideWhenFull = true; // 체력이 가득할 때 숨기기
    [SerializeField] private float hideDelay = 3f; // 숨기기 전 대기 시간
    
    [Header("HP바 크기 설정")]
    [SerializeField] private Vector2 healthBarSize = new Vector2(100f, 15f); // HP바 크기 (픽셀)
    
    [Header("HP바 컴포넌트")]
    private GameObject healthBarInstance;
    private Slider healthSlider;
    private Image fillImage;
    private TextMeshProUGUI healthText;
    private RectTransform healthBarRect;
    
    [Header("색상 설정")]
    [SerializeField] private Gradient healthGradient; // 체력에 따른 색상 변화
    [SerializeField] private Color defaultColor = Color.green;
    [SerializeField] private Color midColor = Color.yellow;
    [SerializeField] private Color lowColor = Color.red;
    
    // 내부 변수
    private Camera mainCamera;
    private Canvas screenCanvas;
    private float maxHealth;
    private float currentHealth;
    private float lastDamageTime;
    private bool isInitialized = false;
    
    // 컴포넌트 참조
    private EnemyController enemyController;
    private MonsterBase monsterBase;
    private StatManager statManager;
    
    private void Awake()
    {
        // 컴포넌트 참조 가져오기
        enemyController = GetComponent<EnemyController>();
        monsterBase = GetComponent<MonsterBase>();
        statManager = GetComponent<StatManager>();
        
        // 메인 카메라 찾기
        mainCamera = Camera.main;
        
        // Gradient 초기화 (인스펙터에서 설정하지 않은 경우)
        if (healthGradient == null || healthGradient.colorKeys.Length == 0)
        {
            InitializeDefaultGradient();
        }
    }
    
    private void Start()
    {
        // 메인 카메라 확인
        if (mainCamera == null)
        {
            mainCamera = Camera.main;
            if (mainCamera == null)
            {
                Debug.LogError("Main Camera not found! HP Bar will not work properly.");
                return;
            }
        }
        
        // 스크린 캔버스 찾기 또는 생성
        FindOrCreateScreenCanvas();
        
        // HP바 생성 및 초기화
        CreateHealthBar();
        InitializeHealth();
        
        Debug.Log($"{gameObject.name}: HP Bar initialized - Canvas: {screenCanvas != null}, HealthBar: {healthBarInstance != null}, Rect: {healthBarRect != null}");
    }
    
    private void InitializeDefaultGradient()
    {
        healthGradient = new Gradient();
        GradientColorKey[] colorKeys = new GradientColorKey[3];
        colorKeys[0] = new GradientColorKey(lowColor, 0.0f);
        colorKeys[1] = new GradientColorKey(midColor, 0.5f);
        colorKeys[2] = new GradientColorKey(defaultColor, 1.0f);
        
        GradientAlphaKey[] alphaKeys = new GradientAlphaKey[2];
        alphaKeys[0] = new GradientAlphaKey(1.0f, 0.0f);
        alphaKeys[1] = new GradientAlphaKey(1.0f, 1.0f);
        
        healthGradient.SetKeys(colorKeys, alphaKeys);
    }
    
    private void FindOrCreateScreenCanvas()
    {
        // 기존 스크린 캔버스 찾기
        GameObject canvasObj = GameObject.Find("EnemyHealthBarCanvas");
        
        if (canvasObj == null)
        {
            // 없으면 새로 생성
            canvasObj = new GameObject("EnemyHealthBarCanvas");
            screenCanvas = canvasObj.AddComponent<Canvas>();
            screenCanvas.renderMode = RenderMode.ScreenSpaceOverlay;
            screenCanvas.sortingOrder = 100; // 다른 UI 위에 표시
            
            // Canvas Scaler 추가
            CanvasScaler scaler = canvasObj.AddComponent<CanvasScaler>();
            scaler.uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;
            scaler.referenceResolution = new Vector2(1920, 1080);
            scaler.screenMatchMode = CanvasScaler.ScreenMatchMode.MatchWidthOrHeight;
            scaler.matchWidthOrHeight = 0.5f;
            
            // Graphic Raycaster 추가 (선택사항)
            // canvasObj.AddComponent<GraphicRaycaster>();
            
            // DontDestroyOnLoad로 설정하여 씬 전환시에도 유지
            DontDestroyOnLoad(canvasObj);
            
            Debug.Log("EnemyHealthBarCanvas created successfully");
        }
        else
        {
            screenCanvas = canvasObj.GetComponent<Canvas>();
        }
        
        // Canvas가 제대로 설정되었는지 확인
        if (screenCanvas == null)
        {
            Debug.LogError("Failed to get or create screen canvas!");
        }
    }
    
    private void CreateHealthBar()
    {
        // HP바 프리팹이 설정되지 않은 경우 기본 HP바 생성
        if (healthBarPrefab == null)
        {
            CreateDefaultHealthBar();
        }
        else
        {
            // 프리팹에서 HP바 생성
            healthBarInstance = Instantiate(healthBarPrefab, screenCanvas.transform);
            
            // 컴포넌트 찾기
            healthBarRect = healthBarInstance.GetComponent<RectTransform>();
            if (healthBarRect == null)
            {
                healthBarRect = healthBarInstance.AddComponent<RectTransform>();
            }
            
            // 앵커 설정
            healthBarRect.anchorMin = new Vector2(0, 0);
            healthBarRect.anchorMax = new Vector2(0, 0);
            healthBarRect.pivot = new Vector2(0.5f, 0.5f);
            
            healthSlider = healthBarInstance.GetComponentInChildren<Slider>();
            if (healthSlider != null)
            {
                fillImage = healthSlider.fillRect.GetComponent<Image>();
            }
            healthText = healthBarInstance.GetComponentInChildren<TextMeshProUGUI>();
        }
        
        // 크기 설정
        if (healthBarRect != null)
        {
            healthBarRect.sizeDelta = healthBarSize;
        }
        
        // null 체크
        if (healthBarRect == null)
        {
            Debug.LogError($"{gameObject.name}: Failed to create health bar RectTransform!");
            return;
        }
        
        isInitialized = true;
    }
    
    private void CreateDefaultHealthBar()
    {
        // HP바 GameObject 생성
        healthBarInstance = new GameObject($"HealthBar_{gameObject.name}");
        healthBarInstance.transform.SetParent(screenCanvas.transform, false);
        
        // RectTransform 설정
        healthBarRect = healthBarInstance.AddComponent<RectTransform>();
        healthBarRect.sizeDelta = healthBarSize;
        healthBarRect.pivot = new Vector2(0.5f, 0.5f);
        healthBarRect.anchorMin = new Vector2(0, 0);
        healthBarRect.anchorMax = new Vector2(0, 0);
        healthBarRect.anchoredPosition = Vector2.zero;
        
        // 배경 이미지
        GameObject background = new GameObject("Background");
        background.transform.SetParent(healthBarInstance.transform, false);
        Image bgImage = background.AddComponent<Image>();
        bgImage.color = new Color(0.2f, 0.2f, 0.2f, 0.8f);
        
        RectTransform bgRect = background.GetComponent<RectTransform>();
        bgRect.anchorMin = Vector2.zero;
        bgRect.anchorMax = Vector2.one;
        bgRect.sizeDelta = Vector2.zero;
        bgRect.anchoredPosition = Vector2.zero;
        
        // 테두리
        GameObject border = new GameObject("Border");
        border.transform.SetParent(healthBarInstance.transform, false);
        Image borderImage = border.AddComponent<Image>();
        borderImage.color = new Color(0.1f, 0.1f, 0.1f, 1f);
        borderImage.type = Image.Type.Sliced;
        
        RectTransform borderRect = border.GetComponent<RectTransform>();
        borderRect.anchorMin = Vector2.zero;
        borderRect.anchorMax = Vector2.one;
        borderRect.sizeDelta = new Vector2(4, 4);
        borderRect.anchoredPosition = Vector2.zero;
        
        // Slider 생성
        GameObject sliderObj = new GameObject("HealthSlider");
        sliderObj.transform.SetParent(healthBarInstance.transform, false);
        healthSlider = sliderObj.AddComponent<Slider>();
        
        RectTransform sliderRect = sliderObj.GetComponent<RectTransform>();
        sliderRect.anchorMin = Vector2.zero;
        sliderRect.anchorMax = Vector2.one;
        sliderRect.sizeDelta = new Vector2(-6, -6);
        sliderRect.anchoredPosition = Vector2.zero;
        
        // Fill Area
        GameObject fillArea = new GameObject("Fill Area");
        fillArea.transform.SetParent(sliderObj.transform, false);
        RectTransform fillAreaRect = fillArea.AddComponent<RectTransform>();
        fillAreaRect.anchorMin = Vector2.zero;
        fillAreaRect.anchorMax = Vector2.one;
        fillAreaRect.sizeDelta = Vector2.zero;
        fillAreaRect.anchoredPosition = Vector2.zero;
        
        // Fill
        GameObject fill = new GameObject("Fill");
        fill.transform.SetParent(fillArea.transform, false);
        fillImage = fill.AddComponent<Image>();
        fillImage.color = defaultColor;
        
        RectTransform fillRect = fill.GetComponent<RectTransform>();
        fillRect.anchorMin = Vector2.zero;
        fillRect.anchorMax = new Vector2(1, 1);
        fillRect.sizeDelta = Vector2.zero;
        fillRect.anchoredPosition = Vector2.zero;
        
        // Slider 설정
        healthSlider.fillRect = fillRect;
        healthSlider.targetGraphic = fillImage;
        healthSlider.interactable = false;
        
        // 체력 텍스트 (선택사항)
        GameObject textObj = new GameObject("HealthText");
        textObj.transform.SetParent(healthBarInstance.transform, false);
        healthText = textObj.AddComponent<TextMeshProUGUI>();
        healthText.text = "";
        healthText.fontSize = 12f;
        healthText.alignment = TextAlignmentOptions.Center;
        healthText.color = Color.white;
        
        RectTransform textRect = textObj.GetComponent<RectTransform>();
        textRect.anchorMin = Vector2.zero;
        textRect.anchorMax = Vector2.one;
        textRect.sizeDelta = Vector2.zero;
        textRect.anchoredPosition = Vector2.zero;
    }
    
    private void InitializeHealth()
    {
        // StatManager를 사용하는 경우 (EnemyController)
        if (statManager != null && enemyController != null)
        {
            maxHealth = statManager.GetValue(StatType.MaxHp);
            currentHealth = statManager.GetValue(StatType.CurHp);
        }
        // MonsterBase를 사용하는 경우
        else if (monsterBase != null)
        {
            maxHealth = monsterBase.maxHealth;
            currentHealth = monsterBase.currentHealth;
        }
        
        UpdateHealthBar();
        
        // 초기 위치 설정
        if (healthBarRect != null && mainCamera != null)
        {
            Vector3 worldPosition = transform.position + worldOffset;
            Vector3 screenPosition = mainCamera.WorldToScreenPoint(worldPosition);
            healthBarRect.position = screenPosition + (Vector3)screenOffset;
        }
        
        // 체력이 가득하면 숨기기
        if (hideWhenFull && currentHealth >= maxHealth)
        {
            healthBarInstance.SetActive(false);
        }
        else
        {
            healthBarInstance.SetActive(true);
        }
    }
    
    private void LateUpdate()
    {
        if (!isInitialized || healthBarInstance == null || healthBarRect == null) return;
        
        // 카메라가 없으면 다시 찾기
        if (mainCamera == null)
        {
            mainCamera = Camera.main;
            if (mainCamera == null) return;
        }
        
        // 몬스터의 월드 위치 계산
        Vector3 worldPosition = transform.position + worldOffset;
        
        // 월드 위치를 스크린 좌표로 변환
        Vector3 screenPosition = mainCamera.WorldToScreenPoint(worldPosition);
        
        // 카메라 뒤에 있는지 체크
        if (screenPosition.z < 0)
        {
            if (healthBarInstance.activeSelf)
                healthBarInstance.SetActive(false);
            return;
        }
        
        // 화면 경계 체크 (여유를 두고)
        bool isOffScreen = screenPosition.x < -100 || screenPosition.x > Screen.width + 100 ||
                          screenPosition.y < -100 || screenPosition.y > Screen.height + 100;
        
        if (isOffScreen)
        {
            if (healthBarInstance.activeSelf)
                healthBarInstance.SetActive(false);
        }
        else
        {
            // 화면 안에 있고 HP바가 표시되어야 하는 경우
            if (currentHealth < maxHealth || !hideWhenFull)
            {
                if (!healthBarInstance.activeSelf)
                {
                    healthBarInstance.SetActive(true);
                }
                
                // HP바 위치 업데이트 (스크린 좌표 + 오프셋)
                Vector3 finalPosition = screenPosition + (Vector3)screenOffset;
                healthBarRect.position = finalPosition;
                
                // 디버그 로그 (필요시 주석 해제)
                // Debug.Log($"{gameObject.name} HP Bar - World: {worldPosition}, Screen: {screenPosition}, Final: {finalPosition}");
            }
        }
        
        // 숨기기 로직
        if (hideWhenFull && healthBarInstance.activeSelf && currentHealth >= maxHealth)
        {
            if (Time.time - lastDamageTime > hideDelay)
            {
                healthBarInstance.SetActive(false);
            }
        }
    }
    
    private void Update()
    {
        if (!isInitialized) return;
        
        // 체력 업데이트만 체크
        UpdateCurrentHealth();
    }
    
    private void UpdateCurrentHealth()
    {
        float newHealth = 0;
        
        // StatManager를 사용하는 경우
        if (statManager != null && enemyController != null)
        {
            newHealth = statManager.GetValue(StatType.CurHp);
        }
        // MonsterBase를 사용하는 경우
        else if (monsterBase != null)
        {
            newHealth = monsterBase.currentHealth;
        }
        
        // 체력이 변경되었는지 확인
        if (Mathf.Abs(newHealth - currentHealth) > 0.01f)
        {
            currentHealth = newHealth;
            UpdateHealthBar();
            
            // 데미지를 받았다면 HP바 표시
            if (currentHealth < maxHealth)
            {
                if (!healthBarInstance.activeSelf)
                {
                    healthBarInstance.SetActive(true);
                }
                lastDamageTime = Time.time;
            }
        }
    }
    
    private void UpdateHealthBar()
    {
        if (healthSlider == null) return;
        
        float healthPercentage = currentHealth / maxHealth;
        healthSlider.value = healthPercentage;
        
        // 색상 업데이트
        if (fillImage != null)
        {
            fillImage.color = healthGradient.Evaluate(healthPercentage);
        }
        
        // 텍스트 업데이트 (선택사항)
        if (healthText != null)
        {
            // 텍스트를 표시하려면 주석 해제
            // healthText.text = $"{Mathf.Ceil(currentHealth)}/{Mathf.Ceil(maxHealth)}";
            // 또는 퍼센트로 표시
            // healthText.text = $"{Mathf.Ceil(healthPercentage * 100)}%";
        }
    }
    
    // 외부에서 체력을 설정할 수 있는 메서드
    public void SetHealth(float current, float max)
    {
        maxHealth = max;
        currentHealth = current;
        UpdateHealthBar();
    }
    
    // HP바 표시/숨기기
    public void ShowHealthBar()
    {
        if (healthBarInstance != null)
        {
            healthBarInstance.SetActive(true);
            lastDamageTime = Time.time;
            
            // 즉시 위치 업데이트
            if (healthBarRect != null && mainCamera != null)
            {
                Vector3 worldPosition = transform.position + worldOffset;
                Vector3 screenPosition = mainCamera.WorldToScreenPoint(worldPosition);
                healthBarRect.position = screenPosition + (Vector3)screenOffset;
            }
        }
    }
    
    public void HideHealthBar()
    {
        if (healthBarInstance != null)
        {
            healthBarInstance.SetActive(false);
        }
    }
    
    private void OnDestroy()
    {
        // HP바 인스턴스 정리
        if (healthBarInstance != null)
        {
            Destroy(healthBarInstance);
        }
    }
    
    private void OnBecameInvisible()
    {
        // 몬스터가 화면에서 사라지면 HP바도 숨기기
        if (healthBarInstance != null)
        {
            healthBarInstance.SetActive(false);
        }
    }
    
    private void OnBecameVisible()
    {
        // 몬스터가 화면에 나타나면 HP바 표시 (체력이 닳은 경우만)
        if (healthBarInstance != null && currentHealth < maxHealth)
        {
            healthBarInstance.SetActive(true);
        }
    }
}
```

